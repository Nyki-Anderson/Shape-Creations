---  
type: TutorialClass  
title: Module_0_Glossary  
description: A comprehensive glossary of terms used in module 0 organized first  
  by module section and then alphabetically. I have attempted defined the terms  
  in my own words, often to build context around what I am discussing. So, links  
  to official definitons have been included for clarification.  
share: true  
category: 0_Getting_Started  
created: Thursday, June 8th 2023, 1:57:23 am  
modified: Thursday, June 8th 2023, 2:48:46 pm  
tags:  
  - glossary  
  - defintions  
  - terms  
  - vocabulary  
  - module-0  
status: updating  
---  
  
  
---  
  
# Module_0_Glossary  
  
---  
  
## [0.1_Note_Taking_with_Obsidian](./0.1_Note_Taking_with_Obsidian.md#)  
  
- **Markdown Language**: Is a pseudo-language that is written completely in plain text, using symbols and quick (hot) keys to format and otherwise customize the appearance of the text, rather than using menus like a traditional word processor. Among the many options: you can bold, italicize, create links, assign different sized headers, etc. all without taking your hands off the keyboard.  
- **Vault & Vault Switcher** : As mentioned previously, [Obsidian](https://obsidian.md/) stores your files on your local file system as opposed to a cloud-based system. The folder in which you store the `.md` files generated by the app is called your “Vault” and the only thing that distinguishes it from your other folders is the `.obsidian` folder, which contains all the configuration for the app. Should you decide to make more than one Vault, you can copy that folder and paste it into your other vaults, otherwise you will need to reconfigure each Vault from scratch.  
- **Zettelkasten** Is a method of linking concepts and notes to related concepts and notes through the use of tags, headers, or other user-defined metadata. In practice, it is proven to reinforce learning, define hidden connections between concepts, and organize large bodies of information.  
  
## [0.2_Development_with_VSCode](./0.2_Development_with_VSCode.md#)  
  
- **Multi-root Workspace** A VSCode environment scope that encompasses the root project folder and all subdirectories, and also contains a `*.code-workspace` file. Within this environment, settings can be prioritized and specified based on the language/s used within the project or just configured for usability. I won’t go into much detail here as I’m most excited to share the extensions but [VSCode](https://code.visualstudio.com/) goes into great detail about settings for each scope (user, workspace, global, etc). You can find that information here : [Multi-root Workspaces in Visual Studio Code](https://code.visualstudio.com/docs/editor/multi-root-workspaces).  
  
## [0.3_Docker_Primer](./0.3_Docker_Primer.md#)  
  
- **Containers** : Once an image has been built successfully, the service is ready to be *containerized* or run. Docker uses the image’s instructions to run an instance of a service and does so until it is stopped and/or removed. Whatever service is being run, be it an Apache server or a MariaDB database, a container built to the exact specifications of an image will do only what is prescribed to do. It will not share state or data with any other container or service.  
  
	Ideally each image and the container run from it are assigned a single task or mode. This is the convention for, not only, security purposes (minimizing the attack surface of a service) but also reducing the overall complexity of a single container.  
  
	Once a container is stopped, the service stops. And once a container is removed any data that was being stored by the service is lost (though we can configure this not to be the case). Essentially, the container is ephemeral but unless specifically removed, the image will still exist and can still be run again without the need to rebuild it. This is convenient when you need to run multiple containers from a single image.  
  
 - **Images** : A Docker image is a read-only blueprint for a service required by a given application or project i.e., a server, a database, or any tool that your project needs. An image (as opposed to a container) does not itself run. It is simply the scaffolding that defines a service: including its configuration, where it stores its data, which port/s it exposes, which network/s it uses, what credentials its has access to, etc.  
  
	These elements are brought together using a `Dockerfile` which builds a layer for each command it contains. You can either use a pre-built image pulled from the [Docker Hub](https://hub.docker.com/) or define your own `Dockerfile` that appends to a base Docker Hub image.  
  
	Whether built from *scratch* or not, every image is based on some Linux distribution, usually Ubuntu or Alpine. This forms the base layer whereupon each consecutive command is layered on top. As such, an image can be thought of as an onion of information describing *how* a service will operate while keeping track of where in its build process each piece of information was obtained. This will be important later when determining how we wish to order the commands in the `Dockerfile`.  
  
	Based on this layering, an image is easily cacheable; only rebuilding layers that have been changed since it was last built. That makes the process of building and rebuilding images quicker and more efficient but also serves as a sort of time capsule that can be reverted to an older layer with a simple command. This can be dangerous if you have hardcoded sensitive data into the either the `Dockerfile` or any of the configuration files as they will be congealed into the layers for anyone to see.  
  
---  
