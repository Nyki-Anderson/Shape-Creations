---  
type: TutorialClass  
title: 0.5-Dockerfiles  
description: We will go over Dockerfile syntax and instruction types. This is  
  how we will build our images (with the help of Docker Compose, covered in the  
  next section).  
share: true  
category: 0-Getting-Started  
created: Thursday, July 6th 2023, 6:49:18 pm  
modified: Friday, July 7th 2023, 6:41:36 pm  
tags:  
  - shapecreations  
media: ""  
status: in-progress  
---  
  
  
# 0.5-Dockerfiles  
  
![](https://img.shields.io/badge/-Docker-2496ED?logo=docker&logoColor=white&style=plastic)  
  
---  
  
## Overview  
  
> 🍎 Definition    
> A Dockerfile is a text file that contains all the commands and information necessary to build an image.  
  
Within a Dockerfile, there are several instruction types that can be used to do anything from run CLI programs, install programs, switch users, copy files from the host to the image, set the runtime command, and more! Before we take a look at our first Dockerfile, we will explore some best use practices and instruction types that you should become familiar with before commencing the project.  
  
The instruction types we will cover in this section and use throughout the project are as listed (in order of appearance):  
  
- [FROM](0.5-Dockerfiles.md#the-from-instruction)  
- [ENV](0.5-Dockerfiles.md#env)  
- [ARG](0.5-Dockerfiles.md#arg)  
- [RUN](0.5-Dockerfiles.md#the-run-instruction)  
- [ADD](0.5-Dockerfiles.md#add)  
- [COPY](0.5-Dockerfiles.md#copy)  
- [VOLUME](0.5-Dockerfiles.md#volume)  
- [USER](0.5-Dockerfiles.md#the-user-instruction)  
- [HEALTHCHECK](0.5-Dockerfiles.md#the-healthcheck-instruction)  
- [EXPOSE](0.5-Dockerfiles.md#the-expose-instruction)  
- [CMD](0.5-Dockerfiles.md#cmd)  
- [ENTRYPOINT](0.5-Dockerfiles.md#entrypoint)  
  
> ✏ Note    
> We will only cover the basic usages of these commands, for a complete reference, check out the [Docker - Dockerfile Reference](https://docs.docker.com/engine/reference/builder/). Much of the information shared in this section comes directly from this resource anyways.  
  
### General Rules  
  
Docker syntax is quite simple at its core. Comments are denoted with a `#` symbol and each command must be on its own line. While not required, all instructions are typically written using ALL CAPS.  
  
```Dockerfile  
# This is a comment  
FROM apache  
```  
  
Since we are writing the instructions to build a nicely packaged Docker image. Instructions are built in order and a few of the instructions themselves denote new layers.  
  
#### Caching  
  
There are some considerations to be had when deciding when and where we put certain instructions. This is because when we build our images, a cache helps keep track of what has changed from the present build to the previous, then only building layers that have changed starting from the first change.  
  
In practice, this means putting instructions that copy code subject to change near the end and simple installations near the beginning so that we don’t have to rebuild installation layers each time a configuration file is changed.  
  
> 🔒 Security    
> Remember, each layer in an image can be inspected with `docker history`! Our layers should not contain any secrets or otherwise sensitive information. We will discuss how to get around this soon.  
  
#### Naming the File  
  
Dockerfiles are usually named `dockerfile` (or some version of that). This helps, especially for VS Code to help auto suggestions. We will be using the `{service_name}.dockerfile` convention in our project as VS Code recognizes it.  
  
> 🔮 Crystal Ball    
 > We want VS Code to recognize these files because it will help us select valid base image variants and versions as well as help with syntax.  
  
#### The `FROM` Instruction  
  
Every Dockerfile needs a `FROM...` instruction at the beginning of the file. This is like the `docker pull` command on the CLI. In general, you can use any base image from the Docker Hub, but there are often variants and specific versions that can be specified.  
  
> ✏ Note    
> It is good practice to specify both of these things in our Dockerfiles as it will protect us from unforeseen differences between versions that can break our builds.  
  
Dockerfiles can be as simple as a `FROM` instruction but if this is all you need, you may as well build your image from the CLI. Nothing can precede a `FROM` instruction except comments or `ARG` instructions.  
  
#### Variable Replacement: The `ENV` & `ARG` Instructions  
  
So I mentioned before that there are some exceptions to the layer per instruction rule. Two of those exceptions are the `ARG` and `ENV` instructions. These instructions are used to pass variables into our image build. We will discuss each individually as they should be used for two distinct purposes. Their shared purpose though is to prevent having to hardcode values that might otherwise be different for different image builds (e.g., development vs. production).  
  
##### `ENV`  
  
The `ENV` instruction is used to replace values both during the image build and during container runtime. This means, `ENV` values can be accessed by the containers after an image is built using the Dockerfile.  
  
There are a number of ways we can set `ENV` variables. There is an order of precedence too that allows certain methods to override others.[^1] That order goes as follows (highest to lowest):  
  
1. Using the `-e` flag in a `docker compose -e` in the CLI.  
2. Substituted from your shell variables.  
3. Set using the `environment` attribute in the `docker-compose.yml` file.  
4. Use of the `--env-file` argument in the CLI  
5. Use of the `env_file` attribute in the Compose file  
6. Set using an `.env` file placed at base of your project directory  
7. Set in a container image in the `ENV` directive. Having any `ARG` or `ENV` setting in a `Dockerfile` evaluates only if there is no Docker Compose entry for `environment`, `env_file` or `run --env`.  
  
We will only consider a select few of these methods as most are not applicable within the scope of this project. When defining an `ENV` variable within the Dockerfile, the `ENV` key is often named using ALL CAPS and the syntax for `ENV` variables is as such:  
  
```Dockerfile  
ENV KEY=value  
  
RUN some_command ${KEY}  
```  
  
> 🔮 Crystal Ball    
> We will learn the syntax for defining `ENV` variables as a Docker Compose attribute in the next section.  
  
Once set in the Dockerfile, `ENV` values cannot be overridden from the command line at build time. They can however be changed after container runtime which can be useful if you wish to have a different value parsed in the container than what was used in the image itself. A common use for this is when you want to run different containers using the same image.  
  
You would very generally use `ENV` variables to pass credentials, certificates, secrets, and other sensitive information to the containers that require them.  
  
> 🔒 Security    
> We will not use `ENV` variables *directly* to send sensitive information to our containers. Instead, we will use a neat service provided by Docker called [Docker Secrets](https://docs.docker.com/engine/swarm/secrets/) (more on this later).  
  
##### `ARG`  
  
The `ARG` instruction is used to pass variables at build time, which means they are only available within the scope of the image, not the container. Usually `ARG` variables are used when the container is not interested in the value or when you need to set a value dynamically at build time.  
  
There are far fewer ways to define an `ARG` variable than for `ENV` variables. Also note that given the same key name, an `ENV` variable will override the value set for the `ARG` variable.  
  
1. Defined at the CLI using `--build-arg` .  
2. Given a default value within a Dockerfile.  
3. Set using the `arg` attribute nested under the `build` attribute of a `docker-compose.yml` file service.  
  
> ⚠ Warning!    
> If an `ARG` variable is used in a Dockerfile but is not defined by one of these methods, a warning will be thrown at build time.  
  
The syntax for `ARG` instructions within a Dockerfile is identical to that of `ENV` instructions:  
  
```Dockerfile  
ARG KEY=value  
  
RUN some_command ${KEY}  
```  
  
> 🔮 Crystal Ball    
> It goes without saying that we will cover the Docker Compose syntax in the next section.  
  
> 🔒 Security    
> `ARG` instructions are *not* a good way to pass secrets, credentials, or other sensitive material to the image! Values passed this are visible to any user with the `docker history` command.[^2]  
  
> 🔦 Flashback    
> As mentioned in the `FROM` instruction heading, the `ARG` instruction is the only instruction that can precede it and the `ARG` itself must only be referenced in that `FROM` instruction, as for, the variant or version number. For example:  
>  
> ```Dockerfile  
> ARG VERSION=2.4.57  
> FROM httpd:${VERSION}  
> ```  
>  
> However, any `ARG` variables set above the `FROM` instruction must be re-declared below it to be made usable to the rest of the build.  
  
Something unique to `ARG` variables is that they can be set from the CLI using `--build-arg {ARGUMENT_VARIABLE}`. `ENV` variables cannot be dynamically changed in this way. This can be done as follows:  
  
```shell  
$ docker build --build-arg VARIABLE=value .  
```  
  
Common use cases for `ARG` variables are version numbers and tags for the base image and when setting a non-root user. We have also elected to use them to simplify host path names that are subject to change as our project directory evolves.  
  
> 🔮 Crystal Ball    
> In a rather unconventional way, we will be using a universal `.env` file to set our `ARG` variables using Docker Compose. This is not necessarily how our final project will handle `ARG` variables but it works and prevents the need to hardcode repetitive values into each Dockerfile. Security considerations on this are inconclusive at the time this Module has been written...  
  
#### The `RUN` Instruction  
  
The `RUN` instruction is one of the most dynamic in the Dockerfile arsenal. Despite its power, it is relatively simple to explain. Use `RUN` to execute any shell program or command inside the image file space.  
  
The `RUN` instruction can take one of two forms:  
  
1. The *shell* form: `RUN <command> ` which should be used whenever executing a command via the `bin/sh -c` shell.  
2. The *exec* form: `RUN ["exectuable", "param1", "param2"]` which can be used to run a command from another shell by setting the `SHELL` instruction. We won’t use this form.  
  
Here is a simple example of using `RUN` to upgrade and update an ubuntu image:  
  
```Dockerfile  
FROM ubuntu:latest  
  
RUN apt-get update && \  
	apt-get upgrade  
```  
  
> ✏ Note    
> Notice in the above example the `\` symbol is being used to separate multiple commands onto different lines. This is best practice as it helps to make code more readable. Consider also, alphabetizing commands listed in this manner to ease in program installations and such.  
  
> 🌎 The Big Picture    
> `RUN` is one of the commands that generates a new layer. Upon reaching a `RUN` instruction, a new read-only layer is added to the top of the current image.  
  
#### The `ADD`, `COPY` & `VOLUME` Instructions  
  
There will be several files needed to be shared between our host computer and docker container; not least of which is the application folder itself! There are several options to do so but they are not necessarily interchangeable. Each comes with its own pros and cons, as well as special functionalities that make them preferable to the others for certain types of files.   
  
> 🔒 Security  
> Pay attention to best use cases for each of these *file sharing* instructions, often our biggest consideration when deciding between the three is whether or not we want to obfuscate or persist data (even when a container is stopped!).  
  
##### `ADD`  
  
##### `COPY`  
  
##### `VOLUME`  
  
#### The `USER` Instruction  
  
#### The `HEALTHCHECK` Instruction  
  
#### The `EXPOSE` Instruction  
  
#### The `CMD` & `ENTRYPOINT` Instructions  
  
The `CMD` & `ENTRYPOINT` instructions are oddballs when compared to the other Dockerfile instructions. First and foremost, they are not a build time instructions like all the others; they are runtime commands that define the default behavior of the `docker run` command.  
  
> ✏ Note    
> When using the *exec* form of either of these commands, be sure  
  
##### `CMD`  
  
`CMD` is used to set a default run command that will execute once a container is started from that particular image (or omit the default run command). A `CMD` instruction can also be overridden during the `docker run` command and will be replaced by whatever is entered at the CLI. `CMD` should be used if your container may be run in interactive mode or will otherwise be run in varying ways.  
  
It can take three forms:  
  
- The preferred form is the *exec* form: `CMD ["executable", "param1", "param2"]`  
- As a default for the `ENTRYPOINT` instruction: `CMD ["param1", "param2"]`  
- The *shell* form in which the `SHELL` instruction should be used to define the desired shell: `CMD executable param1 param2`  
  
There can only be one `CMD` instruction in a given Dockerfile (any duplicates will result only in the last being valid). And it is convention that this instruction be declared at the end of the Dockerfile.  
  
##### `ENTRYPOINT`  
  
Much like the `CMD` instruction, the `ENTRYPOINT` instruction also defines the default command that will be executed once a container is run. By contrast though, the `ENTRYPOINT` instruction cannot be overridden by commands or parameters passed in the `docker run` command. This is why, when possible, `ENTRYPOINT` should be used over `CMD`. Always use `ENTRYPOINT` when you need your container to be run as an executable!  
  
`ENTRYPOINT` can be invoked two ways:  
  
- The preferred form is the *exec* form: `ENTRYPOINT ["executable", "param1", "param2"]`  
- The *shell* form in which the `SHELL` instruction should be used to define the desired shell: `ENTRYPOINT executable param1 param2`  
  
> ✏ Note    
> If need be, `ENTRYPOINT` can be replaced at the CLI using the `--entrypoint` flag when starting up a container.  
  
##### Using `CMD` & `ENTRYPOINT` Together  
  
It was alluded to earlier in this section, but there are some use cases where it is beneficial to use both `CMD` and `ENTRYPOINT` together. We might choose to do so if we have a container that we wish to only be used for a certain command but that might have different or additional parameters passed at run time.  
  
Here is the Dockerfile syntax and the proceeding Docker command for a simple container named `greeting-container` that prints `Hello <name>`. The default command is given by `ENTRYPOINT`, default parameter is given by `CMD` instruction, and if desired, a different parameter may be passed through the `docker run` command to replace that default given by `CMD`:  
  
```Dockerfile  
FROM ubuntu  
ENTRYPOINT ["echo", "Hello"]  
CMD ["Ms. Nyki"]  
```  
  
If we run Version 1 of the command, we get the output `Hello Ms. Nyki`. Version 2 will print out the alternative message of `Hello Ms. Anderson`.  
  
```shell  
# Version 1  
$ docker run greeting-container  
  
# Version 2  
$ docker run greeting-container "Ms. Anderson"  
```  
  
> ✏ Note    
> When using the two instructions together, be sure to use the `exec` form of both.  
  
---  
  
## References  
  
- Docker Docs. 2019 Aug 8. Docker Documentation. <https://docs.docker.com/engine/reference/builder/.>  
  
---  
  
## Footnotes  
  
[^1]: [Environment variables precedence | Docker Documentation](https://docs.docker.com/compose/environment-variables/envvars-precedence/)  
  
[^2]: [Dockerfile reference | Docker Documentation](https://docs.docker.com/engine/reference/builder/#arg)  
