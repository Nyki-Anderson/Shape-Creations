---  
type: TutorialClass  
title: 0.6-Docker-Compose  
description: This section will attempt to explain Docker Compose and the  
  attributes that allow us to build multiple dynamic images with one command.  
share: true  
module: 0-Getting-Started  
created: Saturday, July 8th 2023, 4:50:15 pm  
modified: Monday, July 10th 2023, 1:57:31 am  
tags:  
  - shapecreations  
  - docker  
  - docker-compose  
  - attributes  
  - yaml  
media: ""  
status: in-progress  
---  
  
  
# 0.6-Docker-Compose  
  
---  
  
## Overview  
  
[Docker Compose](https://docs.docker.com/compose/) is a wonderful tool that is used to build and run multi-container Docker projects in one step. It provides a more readable and portable experience when building our images and designing our container runtime behaviors. Anything that can be accomplished in the Docker CLI can be done in a Docker Compose configuration file. Docker Compose is now an extension of Docker itself and has its own syntax.  
  
You can get help for any `docker compose` commands using the `--help` flag just as with any other Docker command.  
  
```shell  
$ docker compose --help  
```  
  
> 🔮 Crystal Ball    
> While Docker Compose relieves us of the need to use Docker fully in the command line, I will attempt to show the equivalent commands to give us some perspective on how helpful the tool really is.    
  
## The `docker-compose.yml` File  
  
The Docker Compose configuration file is written in yaml format which has super easy to learn, element-/attribute-based syntax. This file is generally named `compose.yml` or `docker-compose.yml` but the `docker compose...` command can accept any yaml file using the `-f` flag.  
  
Here is an excerpt from a typical `docker-compose.yml`.  
  
```yml  
version: '3.8'  
services:  
	foo:  
		image: httpd  
	bar:  
		build:  
			context: .  
			dockerfile: Dockerfiles/dockerfile  
```  
  
## Elements & Attributes  
  
There are many possible elements/attributes but not every service will need the same ones, the build is as customizable as possible. We will go through the most important ones, especially those we will make use of through this project. For a complete list of all elements and attributes, visit the [Docker Compose Documentation](https://docs.docker.com/compose/compose-file/)  
  
Top-level elements are not indented and define high-level aspects of the project. They should be justified to the far left of the yaml file. There can be space between the start of each top-level element but it is not necessary, the yaml parser is mostly concerned with white space and tabbed indents. Definitions and attributes are nested using a tabbed indent, following a cascading effect.  
  
### Version (Top-Level)  
  
While not required it is good practice to begin your Docker Compose file with the version with which you want it to be parsed. At the time of this tutorial, Docker Compose is on version 3.8. There are no nested attributes for the `version` element.  
  
```yml  
version: 3.8  
```  
  
### Services (Top-Level)  
  
Every Docker Compose file must include the `services` element. We have used the word **services** throughout this project to describe the various containers we require. This is where we get the term from.  
  
> 🍎 Definition    
> **Services**: A service is an abstract concept. Think of services like resources that can be scaled and configured to your exact specifications and backed by a container. They are our web servers, interpreters, and database management programs: i.e., apache, php, mariadb, etc.  
  
As the root element, each service has a set of definitions that dictate how a container will run and an optional build section that defines the image build. This is where we define the runtime constraints and requirements with which our containers will be designed. Nested under services is a unique identifier that will only be used within the file itself. The majority of our attributes will be nested under this unique identifier.  
  
> ✏ Note    
> The `container_name` attribute is used to define a container name. All images are named using the convention: `COMPOSE_PROJECT_NAME-<container_name>` where `COMPOSE_PROJECT_NAME` is given by the root folder name of the project.  
  
```yml  
services:  
	foo:  
```  
  
Here’s a list of the `servcies` attributes we will cover (in order of appearance):  
  
- [build](0.6-Docker-Compose.md#the-build-subsection)  
	- [context](0.6-Docker-Compose.md#context)  
	- [dockerfile](0.6-Docker-Compose.md#dockerfile)  
	- [args](0.6-Docker-Compose.md#args)  
- [image](0.6-Docker-Compose.md#the-image-attribute)  
- [container_name](0.6-Docker-Compose.md#the-containername-attribute)  
- [restart](0.6-Docker-Compose.md#the-restart-attribute)  
- [ports](0.6-Docker-Compose.md#the-ports-attribute)  
- [env_file](0.6-Docker-Compose.md#the-envfile-attribute)  
- [environment](0.6-Docker-Compose.md#the-environment-attribute)  
- [networks](0.6-Docker-Compose.md#the-networks-attribute)  
- [secrets](0.6-Docker-Compose.md#the-secrets-attribute)  
- [links](0.6-Docker-Compose.md#the-links-attribute)  
- [volumes](0.6-Docker-Compose.md#the-volumes-attribute)  
  
#### The `build` Subsection  
  
The `build` subsection is a special case and is completely optional and it defines build time configuration or images. All of the other sections we will cover (true attributes) deal with runtime configuration or containers. `build` is only necessary when using a custom Dockerfile, such as the ones we will be using.  
  
> 🔮 Crystal Ball    
> If there is no `build` section, the `image` attribute must be used in its place. The `image` attribute is the easiest way to build an image, it is like using the `docker pull IMAGE` command.  
  
Unlike regular attributes, the `build` subsection has its own attributes nested under it. We will talk about the three we will use in our project: (1) `context`, (2) `dockerfile`, and (3) `args`.  
  
##### `context`  
  
The `context` attribute defines the path for `dockerfile` of that service or the URL to a github repository. It defaults to `.` (the directory of the `docker-compose.yml`).  
  
> ⚠ Warning!    
> To use this attribute, without needing the `dockerfile` attribute as well, your Dockerfile must be named `dockerfile` (no extension).  
  
```yml  
services:  
	foo:  
		build:  
			context: `.`  
```  
  
> ✏ Note    
> In my experience, setting this value to `.` or not including it at all tends to be the best option, especially if your project files are kept in separate folders based on file type rather than by image/container. The file system for this project keeps Dockerfiles in their own folder and configuration files for each service in their own folders so the Dockerfile would have difficulty locating these files if we didn’t set the context to the main project directory.  
  
##### `dockerfile`  
  
The `dockerfile` attribute allows us to set a different name for the Dockerfile of the image being built. We will need this as we have opted to use this naming convention: `<service>.dockerfile`.  
  
```yml  
services:  
	foo:  
		build:  
			dockerfile: ./DOCKERFILE  
```  
  
###### `args`  
  
The `args` attribute is completely optional and is elected based on personal preference. It is used when you wish to define `ARG` variables (as in the Dockerfile) in your Docker Compose file instead. You would still need to declare the `ARG` variable name inside the Dockerfile but the actual value can be set in the Docker Compose file.  
  
So with this `ARG` instruction in the Dockerfile:  
  
```Dockerfile  
ARG SOME_ARG  
  
USER ${SOME_ARG}  
```  
  
You can define the value of the variable like this in the Docker Compose file.  
  
```yml  
build:  
	foo:  
		args:   
			- SOME_ARG=some_value  
```  
  
#### The `image` Attribute  
  
The `image` attribute denotes which base image to run the container from. This attribute takes the place of the entire `build` section. The `image` attribute takes an image name from Docker Hub and optionally, a tag and/or version, like our Dockerfile `FROM` instruction.  
  
```yml  
services:  
	foo:  
		image: httpd:2.4.57-alpine3.18  
```  
  
> ⚠ Warning!    
> If not using the `build` section, you must include the `image` attribute. Without an `image` or `build` section, Docker Compose will not work.  
  
#### The `container_name` Attribute  
  
The `container_name` attribute is a string name for the container. If you do not specify this, a default name will be generated. The regex rules for this string are: ‘\[a-zA-Z0-9\]\[a-zA-Z0-9_.-\]+’  
  
```yml  
services:  
	foo:  
		container_name: CONTAINER_NAME  
```  
  
> ✏ Note    
> Specifying a `container_name` will automatically give the image the name `COMPOSE_PROJECT_NAME-CONTAINER_NAME`.  
  
#### The `restart` Attribute  
  
The `restart` attribute determines the policy for the container if its run is terminated. There are four options:  
  
- `no` : This is the default policy and the container will not restart under any circumstances.  
- `always` : This policy will restart the container until it is removed.  
- `on-failure` : This policy will restart the container if an error is thrown.  
- `unless-stopped` : This policy will continue to restart the container until it is stopped or removed.  
  
```yml  
services:  
	foo:  
		restart: "no"  
	    restart: always  
	    restart: on-failure  
	    restart: unless-stopped  
```  
  
#### The `ports` Attribute  
  
The `ports` attribute exposes and maps container ports. Unlike the `EXPOSE` instruction used in Dockerfiles, this is not for documentation. The ports enumerated below will be equivalent to the CLI statement `docker run -p HOST_PORT:CONTAINER_PORT`  
  
```yml  
services:  
	foo:  
		ports:  
			- HOST_PORT:CONTAINER_PORT  
			- 8080:80  
```  
  
#### The `env_file` Attribute  
  
The `env_file` attribute takes a path (relative to the Docker Compose file) to a file containing environment variables for the container. You may specify more than one environment file. Though it is not mandatory, the naming convention for this file is simply `.env` though you can name this file whatever you like.  
  
An environment file simply uses the following syntax to define variables:  
  
```env  
VARIABLE1=value1  
VARIABLE2=value2  
```  
  
To attach an `.env` file to a Docker service, declare under the `env_file` attribute. To then use these variables in your Dockerfile, use the `${VARIABLE1}` or `$VARIABLE1` syntax.  
  
```yml  
services:  
	foo:  
		env_file:   
			- ./ENV_FILE_PATH  
```  
  
> 🔦 Flash Back    
> The order of precedence for environment variables described in the [previous section](./0.5-Dockerfiles.md#env) states that any environment variables defined in an `environments` attribute will overrule those in a file found at the path in the `env_file` attribute.  
  
#### The `environment` Attribute  
  
The `environment` attribute defines environment variables in a container, much in the same way that the `env_file` does. However, these values do supersede any found in an environment file. The syntax for this attribute can take one of two forms:  
  
1. *Mapping* syntax:  
  
```yml  
services:  
	foo:  
		environment:  
			ENV_VAR1: env_value1  
			ENV_VAR2: env_value2  
```  
  
1. *Array* syntax:  
  
```yml  
services:  
	foo:  
		environment:  
			- ENV_VAR1=env_value1  
			- ENV_VAR2=env_value2  
```  
  
#### The `networks` Attribute  
  
The `networks` attribute defines the networks to which services are attached. It references named networks declared in the top-level [networks](0.6-Docker-Compose.md#networks-top-level) element. One of the perks of Docker Compose container orchestration is that it automatically creates a network shared between all of the containers. We will use this built in network for now but it is worth noting how to define your own networks.  
  
There are a lot of attribute options and flags that can be used to design a network definition but we won’t get into them since we have opted to use the built-in Docker Compose network for now.  
  
```yml  
services:  
  foo:  
    networks:  
      - network1  
      - network2  
  
networks:  
	network1:  
	network2:  
```  
  
#### The `secrets` Attribute  
  
When it comes to managing secrets and other sensitive data like certificates and credentials, Docker Swarm offers a service called *secrets*.[^1] Secrets are stored as encrypted files in the container file system at the path `/run/secrets/<secret_name>`. They are released to containers on a per-service basis and are encrypted during transit. Once a container is stopped, the secret is unmounted from the container.  
  
In order to use secrets you must initialize Docker Swarm with the command `docker swarm init`. You can create a secret several different ways:  
  
- From the CLI:  
	- Create from string: `printf "my super secret password"|docker secret create my_secret`  
	- Create from file: `docker secret create SECRET_NAME ./secret.txt`  
- Within the Docker Compose file (see also the [Secrets](0.6-Docker-Compose.md#secrets-top-level) top-level element):  
	- Create a new secret by using the `file` attribute to set the relative path to the secret file.  
	- Reference a secret that already exists: by setting the `external` attribute to `true`.  
  
```yml  
services:  
	foo:  
		secrets:  
			- certificate  
			- gpg_key  
secrets:  
	server_certificate  
		file: ./server.cert  
	gpg_key:  
		external: true  
```  
  
Some images, including the MariaDB base image we will be using, have their own built-in environment variables for secrets. The syntax for such a container will be as follows:  
  
```yml  
services:  
	mariadb:  
		environment:  
			- MARIADB_USER_FILE=/run/secrets/db-user  
			- MARIADB_PASSWORD_FILE=/run/secrets/db-password  
		secrets:  
			- db-user  
			- db-password  
secrets:  
	db-user:  
		file: ./db-user.txt  
	db-password:  
		external: true  
```  
  
#### The `links` Attribute  
  
The `links` attribute does two things: (1) it allows communication between different services across a network and (2) it denotes dependency thus determining the order of service startup. In the case below, the services `foo` and `bar` will be able to communicate over a shared network and `bar` will start before `foo`.  
  
```yml  
services:  
	foo:  
		links:  
			- bar  
	bar:  
```  
  
#### The `volumes` Attribute  
  
The `volumes` attribute defines a bind mount or named volume between a service and the host machine. We will not cover bind mounts at this time (maybe in a future edit) but when it comes to named volumes, there are certain use cases that will change where we declare them (see also: [Volumes (Top-Level)](0.6-Docker-Compose.md#volumes-top-level)).  
  
If a volume is being used by a singular service, it can be declared one of two ways but is not required to be referenced in the top level `volumes` element. There are a lot of optional attributes and flags that can be used, for brevity, we’ve only included those that we either use currently or may use in future edits.  
  
- Long-syntax:  
	- `type`: The mount type. There are more types than this but these are the most popular.:  
		- `volume`  
		- `bind`  
	- `source`: The source of the mount, a path on the host for the bind mount, or the name of volume listed in the top-level volumes key.  
	- `target`: The path in the container where the volume is mounted.  
	- `read_only`: A flag to set the container to read only.  
	- `volume`: Configure additional volume options.  
		- `no_copy`: A flag to disable copying of data into the container when a volume is created.  
  
```yml  
services:  
	foo:  
		volumes:   
			-   type: volume  
			    source: db-data  
		        target: /data  
```  
  
- Short-syntax  
	- `volume`: A volume name.  
	- `container_path`: The path in the container where the volume is mounted.  
	- `access_mode`: A comma separated list of options (optional).  
		- `rw`: Read-write access (default).  
		- `ro`: Read-only access.  
  
```yml  
services:  
	foo:  
		volumes:  
			- VOLUME1:CONTAINER_PATH1:ACCESS_MODE  
			- VOLUME2:CONTAINER_PATH2  
```  
  
> 🔒 Security    
> Volumes are fairly secure innately, however they do lead back to the host machine which increases the attack surface of the project. They are also dependent on the host machine in which the container is being run on. For these purposes, we will exclude volumes from our production build but will still need them in development. To do this, we will make use of multiple Docker Compose files, a master `docker-compose.yml` and a `docker-compose-dev.yml` which will only define our volumes. More on design principles such as this in [this section](../1-Dockerizing/0.0-The-Stack.md#) . Reference the [Using Multiple Docker Compose Files](0.6-Docker-Compose.md#using-multiple-docker-compose-files) heading later in this section for information on using multiple Docker Compose files.  
  
If a volume is to be shared between multiple containers, we must also declare named volumes in the top-level [Volumes](0.6-Docker-Compose.md#volumes-top-level) element. In these cases, the syntax would look like this:  
  
```yml  
services:  
  foo:  
    volumes:  
      - data:/etc/data  
  
  bar:  
    volumes:  
      - data:/var/lib/backup/data  
  
volumes:  
  data:  
```  
  
### Networks (Top-Level)  
  
The `networks` element works in conjunction with attribute within the `services` element (see the [network](0.6-Docker-Compose.md#the-networks-attribute) attribute section for syntax.  
  
### Volumes (Top-Level)  
  
The top-level `volumes` element need only be used if a volume is being shared among multiple containers. Look to the [volumes](0.6-Docker-Compose.md#the-volumes-attribute) attribute section for syntax in this special case. There are a few optional attributes that aid in the specifications for how a volume will function but they are all beyond the scope of this tutorial.  
  
### Secrets (Top-Level)  
  
The top-level `secrets` element *must* be used in all cases when handling secrets. It can either define a new secret or reference a secret that already exists (such as those created in the CLI). Review the [secrets](0.6-Docker-Compose.md#the-secrets-attribute) attribute for syntax.  
  
## Using Environment Variables  
  
The Docker Compose file can use environment variables if those variables are defined in a `.env` file within the same directory. This helps reduce the verboseness of the `docker-compose.yml` file and helps reduce redundancy. We have opted to use this functionality as we define several variables in the `arg` attribute within the `build` subsection.  
  
As demonstrated in the [env_file](0.6-Docker-Compose.md#the-envfile-attribute) attribute heading, the `.env` uses simple `key=value` notation and can be referenced in the Docker Compose file as follows:  
  
```yml  
services:  
	foo:  
		build:  
			args:  
				- VARIABLE=${key}  
```  
  
## Using Multiple Docker Compose Files  
  
There are many instances where our development images and production images need to differ in order to meet the requirements of either environment. For example, in our development images, we may wish to use volumes to provide live access to the contents of a container as well as update our code. In production, this is not necessary and is quite insecure. We may also wish to override certain build elements like excluding a service that is not a part of the production workflow.  
  
Docker enables you to use multiple Docker Compose files simply by using the `-f` flag and providing the path to the additional files.  
  
---  
  
## References  
  
- *Compose file version 3 reference*. (2019, May 8). Docker Documentation. <https://docs.docker.com/compose/compose-file/>    
‌  
---  
  
## Footnotes  
  
[^1]: [Manage sensitive data with Docker secrets | Docker Documentation](https://docs.docker.com/engine/swarm/secrets/)  
