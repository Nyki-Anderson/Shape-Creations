---  
type: TutorialClass  
title: 0.6-Docker-Compose  
description: This section will attempt to explain Docker Compose and the  
  attributes that allow us to build multiple dynamic images with one command.  
share: true  
module: 0-Getting-Started  
created: Saturday, July 8th 2023, 4:50:15 pm  
modified: Sunday, July 9th 2023, 6:37:35 am  
tags:  
  - shapecreations  
  - docker  
  - docker-compose  
  - attributes  
media: ""  
status: in-progress  
---  
  
  
# 0.6-Docker-Compose  
  
---  
  
## Overview  
  
[Docker Compose](https://docs.docker.com/compose/) is a wonderful tool that is used to build and run multi-container Docker projects in one step. It provides a more readable and portable experience when building our images and designing our container runtime behaviors. Anything that can be accomplished in the Docker CLI can be done in a Docker Compose configuration file. Docker Compose is now an extension of Docker itself and has its own syntax.  
  
You can get help for any `docker compose` commands using the `--help` flag just as with any other Docker command.  
  
```shell  
$ docker compose --help  
```  
  
> 🔮 Crystal Ball    
> While Docker Compose relieves us of the need to use Docker fully in the command line, I will attempt to show the equivalent commands to give us some perspective on how helpful the tool really is.    
  
## The `docker-compose.yml` File  
  
The Docker Compose configuration file is written in yaml format which has super easy to learn, element-/attribute-based syntax. This file is generally named `compose.yml` or `docker-compose.yml` but the `docker compose...` command can accept any yaml file using the `-f` flag.  
  
Here is an excerpt from a typical `docker-compose.yml`.  
  
```yml  
version: '3.8'  
services:  
	foo:  
		image: httpd:2.4.5  
	bar:  
		build:  
			context: .  
			dockerfile: Dockerfiles/dockerfile  
```  
  
## Elements & Attributes  
  
There are many possible elements/attributes but not every service will need the same ones, the build is as customizable as possible. We will go through the most important ones, especially those we will make use of through this project. For a complete list of all elements and attributes, visit the [Docker Compose Documentation](https://docs.docker.com/compose/compose-file/)  
  
Top-level elements are not indented and define high-level aspects of the project. They should be justified to the far left of the yaml file. There can be space between the start of each top-level element but it is not necessary, the yaml parser is mostly concerned with white space and tabbed indents. Definitions and attributes are nested using a tabbed indent, following a cascading effect.  
  
### Version (Top-Level)  
  
While not required it is good practice to begin your Docker Compose file with the version with which you want it to be parsed. At the time of this tutorial, Docker Compose is on version 3.8. There are no nested attributes for the `version` element.  
  
```yaml  
version: 3.8  
```  
  
### Services (Top-Level)  
  
Every Docker Compose file must include the `services` element. We have used the word **services** throughout this project to describe the various containers we require. This is where we get the term from.  
  
> 🍎 Definition    
> **Services**: A service is an abstract concept. Think of services like resources that can be scaled and configured to your exact specifications and backed by a container. They are our web servers, interpreters, and database management programs: i.e., apache, php, mariadb, etc.  
  
As the root element, each service has a set of definitions that dictate how a container will run and an optional build section that defines the image build. This is where we define the runtime constraints and requirements with which our containers will be designed. Nested under services is a unique identifier that will only be used within the file itself. The majority of our attributes will be nested under this unique identifier.  
  
> ✏ Note    
> The `container_name` attribute is used to define a container name. All images are named using the convention: `COMPOSE_PROJECT_NAME-<container_name>` where `COMPOSE_PROJECT_NAME` is given by the root folder name of the project.  
  
```yml  
services:  
	foo:  
```  
  
Here’s a list of the `servcies` attributes we will cover (in order of appearance):  
  
- [build](0.6-Docker-Compose.md#the-build-subsection)  
	- [context](0.6-Docker-Compose.md#context)  
	- [dockerfile](0.6-Docker-Compose.md#dockerfile)  
	- [args](0.6-Docker-Compose.md#args)  
- [image](0.6-Docker-Compose.md#the-image-attribute)  
- [container_name](0.6-Docker-Compose.md#the-containername-attribute)  
- [restart](0.6-Docker-Compose.md#the-restart-attribute)  
- [ports](0.6-Docker-Compose.md#the-ports-attribute)  
- [env_file](0.6-Docker-Compose.md#the-envfile-attribute)  
- [environment](0.6-Docker-Compose.md#the-environment-attribute)  
- [secrets](0.6-Docker-Compose.md#the-secrets-attribute)  
- [links](0.6-Docker-Compose.md#the-links-attribute)  
- [volumes](0.6-Docker-Compose.md#the-volumes-attribute)  
  
#### The `build` Subsection  
  
The `build` subsection is a special case and is completely optional and it defines build time configuration or images. All of the other sections we will cover (true attributes) deal with runtime configuration or containers. `build` is only necessary when using a custom Dockerfile, such as the ones we will be using.  
  
> 🔮 Crystal Ball    
> If there is no `build` section, the `image` attribute must be used in its place. The `image` attribute is the easiest way to build an image, it is like using the `docker pull IMAGE` command.  
  
Unlike regular attributes, the `build` subsection has its own attributes nested under it. We will talk about the three we will use in our project: (1) `context`, (2) `dockerfile`, and (3) `args`.  
  
##### `context`  
  
The `context` attribute defines the path for `dockerfile` of that service or the URL to a github repository. It defaults to `.` (the directory of the `docker-compose.yml`).  
  
> ⚠ Warning!    
> To use this attribute, without needing the `dockerfile` attribute as well, your Dockerfile must be named `dockerfile` (no extension).  
  
```yaml  
services:  
	foo:  
		build:  
			context: `.`  
```  
  
> ✏ Note    
> In my experience, setting this value to `.` or not including it at all tends to be the best option, especially if your project files are kept in separate folders based on file type rather than by image/container. The file system for this project keeps Dockerfiles in their own folder and configuration files for each service in their own folders so the Dockerfile would have difficulty locating these files if we didn’t set the context to the main project directory.  
  
##### `dockerfile`  
  
The `dockerfile` attribute allows us to set a different name for the Dockerfile of the image being built. We will need this as we have opted to use this naming convention: `<service>.dockerfile`.  
  
```yaml  
services:  
	foo:  
		build:  
			dockerfile: ./DOCKERFILE  
```  
  
###### `args`  
  
The `args` attribute is completely optional and is elected based on personal preference. It is used when you wish to define `ARG` variables (as in the Dockerfile) in your Docker Compose file instead. You would still need to declare the `ARG` variable name inside the Dockerfile but the actual value can be set in the Docker Compose file.  
  
So with this `ARG` instruction in the Dockerfile:  
  
```Dockerfile  
ARG SOME_ARG  
  
USER ${SOME_ARG}  
```  
  
You can define the value of the variable like this in the Docker Compose file.  
  
```yaml  
build:  
	foo:  
		args:   
			- SOME_ARG=some_value  
```  
  
#### The `image` Attribute  
  
The `image` attribute denotes which base image to run the container from. This attribute takes the place of the entire `build` section. The `image` attribute takes an image name from Docker Hub and optionally, a tag and/or version, like our Dockerfile `FROM` instruction.  
  
```yaml  
services:  
	foo:  
		image: httpd:2.4.57-alpine3.18  
```  
  
> ⚠ Warning!    
> If not using the `build` section, you must include the `image` attribute. Without an `image` or `build` section, Docker Compose will not work.  
  
#### The `container_name` Attribute  
  
The `container_name` attribute is a string name for the container. If you do not specify this, a default name will be generated. The regex rules for this string are: ‘\[a-zA-Z0-9\]\[a-zA-Z0-9_.-\]+’  
  
```yaml  
services:  
	foo:  
		container_name: CONTAINER_NAME  
```  
  
> ✏ Note    
> Specifying a `container_name` will automatically give the image the name `COMPOSE_PROJECT_NAME-CONTAINER_NAME`.  
  
#### The `restart` Attribute  
  
The `restart` attribute determines the policy for the container if its run is terminated. There are four options:  
  
- `no` : This is the default policy and the container will not restart under any circumstances.  
- `always` : This policy will restart the container until it is removed.  
- `on-failure` : This policy will restart the container if an error is thrown.  
- `unless-stopped` : This policy will continue to restart the container until it is stopped or removed.  
  
```yaml  
services:  
	foo:  
		restart: "no"  
	    restart: always  
	    restart: on-failure  
	    restart: unless-stopped  
```  
  
#### The `ports` Attribute  
  
The `ports` attribute exposes and maps container ports. Unlike the `EXPOSE` instruction used in Dockerfiles, this is not for documentation. The ports enumerated below will be equivalent to the CLI statement `docker run -p HOST_PORT:CONTAINER_PORT`  
  
```yaml  
services:  
	foo:  
		ports:  
			- HOST_PORT:CONTAINER_PORT  
			- 8080:80  
```  
  
#### The `env_file` Attribute  
  
The `env_file` attribute takes a path (relative to the Docker Compose file) to a file containing environment variables for the container. You may specify more than one environment file. Though it is not mandatory, the naming convention for this file is simply `.env` though you can name this file whatever you like.  
  
```yaml  
services:  
	foo:  
		env_file:   
			- ./ENV_FILE_PATH  
```  
  
> 🔦 Flash Back    
> The order of precedence for environment variables described in the [previous section](./0.5-Dockerfiles.md#env) states that any environment variables defined in an `environments` attribute will overrule those in a file found at the path in the `env_file` attribute.  
  
#### The `environment` Attribute  
  
The `environment` attribute defines environment variables in a container, much in the same way that the `env_file` does. However, these values do supersede any found in an environment file. The syntax for this attribute can take one of two forms:  
  
1. *Mapping* syntax:  
  
```yaml  
services:  
	foo:  
		environment:  
			ENV_VAR1: env_value1  
			ENV_VAR2: env_value2  
```  
  
1. *Array* syntax:  
  
```yaml  
services:  
	foo:  
		environment:  
			- ENV_VAR1=env_value1  
			- ENV_VAR2=env_value2  
```  
  
#### The `secrets` Attribute  
  
When it comes to managing secrets and other sensitive data like certificates and credentials, Docker Swarm offers a service called *secrets*.[^1] Secrets are stored as encrypted files in the container file system at the path `/run/secrets/<secret_name>`. They are released to containers on a per-service basis and are encrypted during transit. Once a container is stopped, the secret is unmounted from the container.  
  
In order to use secrets you must initialize Docker Swarm with the command `docker swarm init`. You can create a secret several different ways:  
  
- From the CLI:  
	- Create from string: `printf "my super secret password"|docker secret create my_secret`  
	- Create from file: `docker secret create my_secret ./secret.json`  
- Within the Docker Compose file ([see also](0.6-Docker-Compose.md#secrets-top-level)):  
  
```yaml  
services:  
	foo:  
		secrets:  
			- server_certificate  
secrets:  
	server_certificate  
		file: ./server.cert  
```  
  
Some images, including the MariaDB base image we will be using, have their own built-in environment variables for secrets. The syntax for such a container will be as follows:  
  
```yaml  
services:  
	mariadb:  
		environment:  
			- MARIADB_USER_FILE=/run/secrets/db-user  
			- MARIADB_PASSWORD_FILE=/run/secrets/db-password  
		secrets:  
			- db-user  
			- db-password  
secrets:  
	db-user:  
		file: ./db-user.txt  
	db-password:  
		file: ./db-password.txt  
```  
  
#### The `links` Attribute  
  
The `links` attribute does two things: (1) it allows communication between different services across a network and (2) it denotes dependency thus determining the order of service startup. In the case below, the services `foo` and `bar` will be able to communicate over a shared network and `bar` will start before `foo`.  
  
```yaml  
services:  
	foo:  
		links:  
			- bar  
	bar:  
```  
  
#### The `volumes` Attribute  
  
The `volumes` attribute defines a host mount or named volume between a service and the host machine.  
  
> 🔒 Security    
> Volumes are fairly secure innately as they  
  
### Networks (Top-Level)  
  
### Volumes (Top-Level)  
  
### Secrets (Top-Level)  
  
## Using Variables in the Docker Compose File  
  
---  
  
## References  
  
- *Compose file version 3 reference*. (2019, May 8). Docker Documentation. <https://docs.docker.com/compose/compose-file/>    
‌  
---  
  
## Footnotes  
  
[^1]: [Manage sensitive data with Docker secrets | Docker Documentation](https://docs.docker.com/engine/swarm/secrets/)  
